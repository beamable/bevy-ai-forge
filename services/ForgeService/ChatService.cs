using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;
using ForgeService.Storage;
using Google.GenAI;
using Google.GenAI.Types;
using Newtonsoft.Json;
using OpenAI.Chat;

namespace Beamable.ForgeService;

public interface IChatService
{
    bool TryInit(RealmConfig config, out IChatService chat);

    Promise<string> Prompt(string input);

    public Promise<string> GenerateImage(string input);

}

public class OpenAiChat : IChatService
{
    private ChatClient _client = null;
    public bool TryInit(RealmConfig config, out IChatService chat)
    {
        var apiKey = config.GetSetting("ForgeService", "openApiKey", string.Empty);
        
        var apiModel = config.GetSetting("ForgeService", "openApiModel", string.Empty);
        if (string.IsNullOrEmpty(apiKey) || string.IsNullOrEmpty(apiModel))
        {
            chat = null;
            return false;
        }
        _client = new ChatClient(model: apiModel, apiKey: apiKey);
        chat = this;
        return true;
    }


    public Promise<string> GenerateImage(string input)
    {
        throw new NotImplementedException();
    }
    public async Promise<string> Prompt(string input)
    {
        var aiResponse = await _client.CompleteChatAsync([new UserChatMessage(input)], new ChatCompletionOptions
        {
            Temperature = (float?)0.9,
            MaxOutputTokenCount = 1500,
        });
        return ChatAiService.CleanupString(aiResponse.Value.Content.FirstOrDefault().Text);
    }
}
public class GeminiChat : IChatService
{
    private Client _googleChat = null;
    private IContentApi _contentApi;
    private Promise init;

    public GeminiChat(IContentApi contentApi)
    {
        _contentApi = contentApi;
    }
    public bool TryInit(RealmConfig config, out IChatService chat)
    {
        var apiKey = config.GetSetting("ForgeService", "geminiApiKey", string.Empty);
        if (string.IsNullOrEmpty(apiKey))
        {
            chat = null;
            return false;
        }
        _googleChat = new Client(apiKey: apiKey);
        chat = this;
        return true;
    }

    public async Promise<string> Prompt(string input)
    {
        var generateContentConfig =
            new GenerateContentConfig {
                SystemInstruction = new Google.GenAI.Types.Content
                {
                    Parts = new List<Part> {
                        new Part {Text = input}
                    }
                },
                Temperature = 0.9,
            };
        var response = await _googleChat.Models.GenerateContentAsync(
            model: "gemini-2.5-flash",
            contents: "high",
            config: generateContentConfig
        );
        return ChatAiService.CleanupString(string.Join(' ', response.Candidates.FirstOrDefault().Content.Parts.Select(p => p.Text)));
    }
    
    [ClientCallable]
    public async Promise<string> GetImageUri(byte[] imageBytes)
    {
        var httpClient = new HttpClient();
        var md5Bytes = MD5.HashData(imageBytes);
        var renderChecksum = BitConverter.ToString(md5Bytes).Replace("-", "");
        var saveBinaryResponse = await _contentApi.PostBinary(new SaveBinaryRequest
        {
            binary = new[]
            {
                new BinaryDefinition
                {
                    id = "profile_picture",
                    checksum = renderChecksum,
                    uploadContentType = "image/png"
                }
            }
        });

        var binaryResponse = saveBinaryResponse.binary.First();
        var signedUrl = binaryResponse.uploadUri;

        var content = new ByteArrayContent(imageBytes);
        content.Headers.ContentType = new MediaTypeHeaderValue("image/png");
        content.Headers.ContentMD5 = md5Bytes;

        var putContentResponse = await httpClient.PutAsync(signedUrl, content);
        putContentResponse.EnsureSuccessStatusCode();

        return binaryResponse.uri;
    }

    public async Promise<string> GenerateImage(string input)
    {
        var generateImagesConfig = new GenerateImagesConfig
        {
            NumberOfImages = 1,
            AspectRatio = "1:1",
            SafetyFilterLevel = SafetyFilterLevel.BLOCK_LOW_AND_ABOVE,
            PersonGeneration = PersonGeneration.DONT_ALLOW,
            IncludeSafetyAttributes = true,
            IncludeRaiReason = true,
            OutputMimeType = "image/jpeg"
        };
        var response = await _googleChat.Models.GenerateImagesAsync(
            model: "imagen-4.0-fast-generate-001",
            prompt: input,
            config: generateImagesConfig
        );
        // Do something with the generated image
        var image = response.GeneratedImages.First().Image;
        var url = await GetImageUri(image.ImageBytes);
        return url;

    }
}
public class ChatAiService
{
    private readonly IMicroserviceRealmConfigService _realmConfigService;
    private Promise<IChatService> _initPromise;
    private IChatService _chat = null;
    private IContentApi _contentApi;

    public ChatAiService(IMicroserviceRealmConfigService realmConfigService,  IContentApi contentApi)
    {
        _realmConfigService = realmConfigService;
        _contentApi = contentApi;
    }

    public Promise<IChatService> GetChat()
    {
        if (_initPromise != null && (!_initPromise.IsCompleted || !_initPromise.IsFailed))
        {
            return _initPromise;
        }
        _initPromise = new Promise<IChatService>();
        _realmConfigService.GetRealmConfigSettings().Then(config =>
        {
            var geminiChat = new GeminiChat(_contentApi);
            if (geminiChat.TryInit(config, out var chat))
            {
                _chat = chat;
                _initPromise.CompleteSuccess(_chat);
                return;
            }

            var openAiChat = new OpenAiChat();
            if (!openAiChat.TryInit(config, out chat))
            {
                BeamableLogger.LogError("Failed to get open api key and openApiModel from config");
                _initPromise.CompleteError(new Exception("Failed to get open api key and openApiModel from config"));
            }

            _chat = chat;
            _initPromise.CompleteSuccess(_chat);
            
        });
        
        return _initPromise;
    }

    public Promise<string> GenerateImage(string p)
    {
        return _chat.GenerateImage(p);
    }
    
    public async Task<AiInventoryItem> MakeNewInventoryItem(AiItemContent item, string id, long forgedTimes)
    {
        var prompt = item.Prompt(forgedTimes);
        var aiProps = new Dictionary<string, string>();
        try
        {
            BeamableLogger.Log("Sending {Prompt} to OpenAI API...", prompt);
            var aiResponse = await _chat.Prompt(prompt);
            BeamableLogger.Log("Received responses {C}", aiResponse);

            if (TryParseAiResponse(aiResponse, out aiProps))
            {
                aiProps["price"] = CalculatePrice(aiResponse).ToString();
            }
        }
        catch(Exception ex)
        {
            BeamableLogger.LogError("Calling AI backend failed");
            BeamableLogger.LogError(ex);
        }
        if(!aiProps.ContainsKey("price"))
        {
            aiProps.Add("price", CalculatePrice(prompt).ToString());
        }
        return new AiInventoryItem
        {
            ContentId = item.Id,
            GamerTag = id,
            Properties = aiProps
        };
    }
    public static bool TryParseAiResponse(string response, out Dictionary<string, string> aiProps)
    {
        aiProps = null;
        if (string.IsNullOrWhiteSpace(response)) 
            return false;
        try
        {
            aiProps = JsonConvert.DeserializeObject<Dictionary<string, string>>(response);
            return true;
        }
        catch (Exception ex)
        {
            BeamableLogger.LogError(ex);
            return false;
        }
    }
    public static int CalculatePrice(string input)
    {
        const int basePrice = 51;
        const int randomize = 33;
        return Math.Abs(input.GetHashCode()) % randomize + basePrice;
    }
    public static string CleanupString(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }
        
        var startIndex = 0;
        for (; startIndex < input.Length; startIndex++)
        {
            if (input[startIndex].Equals('{'))
            {
                break;
            }
        }
        var endIndex = input.Length - 1;
        for (; endIndex >= startIndex; endIndex--)
        {
            if (input[endIndex].Equals('}'))
            {
                endIndex += 1;
                break;
            }
        }

        if (startIndex >= endIndex)
            return string.Empty;
        return input[startIndex..endIndex].Replace("\\\"", "\"");
    }
}