using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Inventory;
using Beamable.Common.Api.Stats;
using Beamable.Common.Content;
using Beamable.Common.Scheduler;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using Beamable.Server;
using Beamable.Server.Api.Content;
using Beamable.Server.Api.RealmConfig;
using ForgeService.Storage;
using MongoDB.Driver;
using Newtonsoft.Json;
using OpenAI.Chat;

namespace Beamable.ForgeService
{
    [FederationId("OpenAI")]
	public class AiCloudIdentity : IFederationId;

	[Microservice("ForgeService")]
	public partial class ForgeService : Microservice, IFederatedInventory<AiCloudIdentity>, IFederatedLogin<AiCloudIdentity>
	{
        const string SwordContentId = "items.AiItemContent.AiSword";
        const string ShieldContentId = "items.AiItemContent.AiShield";

        [ConfigureServices]
        public static void ConfigureServices(IServiceBuilder builder)
        {
            builder.AddSingleton(provider => new ChatAiService(provider.GetService<IMicroserviceRealmConfigService>(), provider.GetService<IContentApi>()));
            builder.AddSingleton(provider => new AiContentService(provider.GetService<IMicroserviceContentApi>()));
        }
        
        [InitializeServices]
        public static async Task Initialize(IServiceInitializer initializer)
        {
            try
            {
                var t = initializer.GetService<AiContentService>().Init();
                _ = await initializer.GetService<ChatAiService>().GetChat();
                await t;
            }
            catch (Exception e)
            {
                throw new MicroserviceException((int)HttpStatusCode.BadRequest, "ConfigurationError",
                    e.Message);

            }
        }

		public async Promise<FederatedInventoryProxyState> GetInventoryState(string id)
		{
            BeamableLogger.LogWarning($"GetInventoryState {id}");
            BeamableLogger.LogWarning($"GetInventoryState services: {Services != null}");
            BeamableLogger.LogWarning($"GetInventoryState ctx: {Context != null}");
            BeamableLogger.LogWarning($"GetInventoryState signed requester: {SignedRequester != null}");
            BeamableLogger.LogWarning($"GetInventoryState requester: {Requester != null}");
			var db = await Storage.ForgeStorageDatabase();
			var items = await AiInventoryItemCollection.GetAll(db, id);
			return items.ToFederatedInventoryProxyState();
		}
        public async Promise<FederatedInventoryProxyState> StartInventoryTransaction(string id, string transaction, Dictionary<string, long> currencies, List<FederatedItemCreateRequest> newItems, List<FederatedItemDeleteRequest> deleteItems,
            List<FederatedItemUpdateRequest> updateItems)
        {
            var beamId = Context.UserId;
            var stopWatch = Stopwatch.StartNew();
            BeamableLogger.LogWarning($"StartInventoryTransaction {id} - {beamId}: new items amount {newItems.Count}, delete items amount: {deleteItems.Count}");
            try
            {
                var db = await Storage.ForgeStorageDatabase();
                var contentApi = Provider.GetService<AiContentService>();
                var chat = Provider.GetService<ChatAiService>();
                var signedRequester = SignedRequester;
                var scheduler = Services.Scheduler;
                BeamableLogger.Log($"Is signedRequester empty: {signedRequester == null}");
                signedRequester!.SetPlayerId(id);
                var tasks = new List<Promise<Unit>>();
                var oldItemsPromise = AiInventoryItemCollection.GetAll(db, id);
                var concurentItems = new ConcurrentBag<AiInventoryItem>();
                foreach (var newItem in newItems)
                {
                    tasks.Add(Task.Run(async () =>
                    {
                        var startTime = stopWatch.Elapsed.TotalMilliseconds;
                        BeamableLogger.Log("Starting insert task for {item} at {StartTime}", newItem.contentId, startTime);
                        if (!contentApi.TryGetContent(newItem.contentId, out var aiItemContent))
                        {
                            BeamableLogger.LogWarning("{ContentId} is not an AiItemContent", newItem.contentId);
                            return;
                        }
                        try
                        {
                            long forgedTimes = 0;
                            if (newItem.properties.TryGetValue("forgedTimes", out var value))
                            {
                                if (long.TryParse(value, out var result))
                                {
                                    forgedTimes = result;
                                }
                            }
                            var sss = stopWatch.ElapsedMilliseconds;
                            BeamableLogger.Log($"Forged times of {{itemType}}: {forgedTimes} at {{Time}}", aiItemContent.itemType, sss);

                            var newAiItem = await chat.MakeNewInventoryItem(aiItemContent, id, forgedTimes);
                            BeamableLogger.Log("Created item with AI after {time}", stopWatch.ElapsedMilliseconds);

                            await AiInventoryItemCollection.Save(db, newAiItem);
                            concurentItems.Add(newAiItem);
                            var endTime = stopWatch.ElapsedMilliseconds;
                            BeamableLogger.Log("Saved item {ID} at {endTime}", newAiItem.ItemId, endTime);
                            if (!newAiItem.Properties.ContainsKey("image"))
                            {
                                await scheduler.Schedule().Microservice<ForgeService>().Run(t => t.RebuildItem, newAiItem.ItemId, forgedTimes)
                                    .After(TimeSpan.FromSeconds(10)).Save($"rebuild-item-{newAiItem.ItemId}");
                            }
                            TryBumpStat(signedRequester, beamId, aiItemContent.StatKey(), 1);
                        }
                        catch (Exception ex)
                        {
                            var endTime = stopWatch.Elapsed.TotalMilliseconds;
                            BeamableLogger.LogError("Exception during item add after {endTime} with exception {exception}", endTime, ex);
                        }
                    }).ToPromise());
                }

                foreach (var deleteItem in deleteItems)
                {
                    tasks.Add(Task.Run(async () =>
                    {
                        try
                        {
                            var startTime = stopWatch.Elapsed.TotalMilliseconds;
                            BeamableLogger.Log("Starting delete task for {item} at {StartTime}", deleteItem.contentId, startTime);
                            await AiInventoryItemCollection.DeleteByKey(db, deleteItem.proxyId);
                            var endTime = stopWatch.Elapsed.TotalMilliseconds;
                            BeamableLogger.Log("Removed item {ID} at {endTime}", deleteItem.proxyId, endTime);
                        }
                        catch (Exception ex)
                        {
                            var endTime = stopWatch.Elapsed.TotalMilliseconds;
                            BeamableLogger.LogError("Exception during item removal after {endTime} with exception {exception}", endTime, ex);
                        }
                    }).ToPromise());
                }

                await Promise.Sequence(tasks);
                var jobs = new List<Promise<Job>>();
                var timer = 1;
                foreach (var ii in concurentItems)
                {
                    jobs.Add(Services.Scheduler.Schedule().Microservice<ForgeService>().Run(t => t.GenerateImage, ii.ItemId)
                        .After(TimeSpan.FromSeconds(timer)).Save($"genImage-{ii.ItemId}"));
                    timer += 2;
                }
                var updateTime = stopWatch.Elapsed.TotalMilliseconds;   
                BeamableLogger.Log("updated items after {Duration}", updateTime);

                var itemsResult = await oldItemsPromise;
                var oldItemsTime = stopWatch.Elapsed.TotalMilliseconds;   
                BeamableLogger.Log("got old items after {Duration}", oldItemsTime);
                itemsResult = itemsResult.Where(item =>
                {
                    if (deleteItems.Any(i => i.proxyId == item.ItemId))
                    {
                        return false;
                    }

                    return true;
                }).ToList();
                itemsResult.AddRange(concurentItems);
                await Promise.Sequence(jobs);
                var ddd = stopWatch.Elapsed.TotalMilliseconds;
                BeamableLogger.Log("Scheduled jobs after {Duration}", ddd);
                // if (tasks.Count > 0)
                // {
                //     var time = stopWatch.Elapsed.TotalMilliseconds;
                //     BeamableLogger.Log("Reporting back state for {ID} after {Duration}", beamId, time);
                //     await signedRequester.Request<CommonResponse>(Method.PUT,
                //         $"/object/inventory/{beamId}/proxy/state",
                //         items.ToFederatedInventoryProxyState());
                // }
                var dd = stopWatch.Elapsed.TotalMilliseconds;
                BeamableLogger.Log("Complete after {Duration}", dd);
                return itemsResult.ToFederatedInventoryProxyState();
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
                throw;
            }
        }


        [Serializable]
        class StatsRequest
        {
            public string stats;
        }
        [Serializable]
        public class StatsFullResponse : JsonSerializable.ISerializable
        {
            public long id;
            public MapOfString stats = new MapOfString();
            public MapOfLong statsNumeric = new MapOfLong();

            public virtual void Serialize(JsonSerializable.IStreamSerializer s)
            {
                s.Serialize("id", ref this.id);
                // s.SerializeDictionary<MapOfString, string>("stats", ref this.stats);
                if (s.isLoading)
                {
                    var ss = s.GetValue("stats") as ArrayDict;
                    stats.Clear();
                    statsNumeric.Clear();
                    if (ss is null)
                    {
                        return;
                    }
                    foreach (var (key, value) in ss)
                    {
                        if (value is long l)
                        {
                            statsNumeric.Add(key, l);
                        }
                        else
                        {
                            stats.Add(key, value.ToString());
                        }
                    }
                }

                if (s.isSaving)
                {
                    var array = new ArrayDict();
                    foreach (var (key, value) in stats)
                    {
                        array.Add(key, value);
                    }

                    foreach (var (k,v) in statsNumeric)
                    {
                        array.Add(k, v);
                    }
                    s.SetValue("stats", array);
                }
            }
        }

        [Serializable]
        public class StatIntUpdateRequest : JsonSerializable.ISerializable
        {
            public OptionalMapOfLong add = new OptionalMapOfLong();
            public OptionalBool emitAnalytics = new OptionalBool();
            public OptionalString objectId = new OptionalString();
            public OptionalMapOfInt set = new OptionalMapOfInt();

            public virtual void Serialize(JsonSerializable.IStreamSerializer s)
            {
                if (s.HasKey("add") || this.add != null && this.add.HasValue)
                {
                    s.SerializeDictionary<MapOfLong, long>("add", ref this.add.Value);
                    this.add.HasValue = true;
                }
                if (s.HasKey("emitAnalytics") || this.emitAnalytics != null && this.emitAnalytics.HasValue)
                {
                    s.Serialize("emitAnalytics", ref this.emitAnalytics.Value);
                    this.emitAnalytics.HasValue = true;
                }
                if (s.HasKey("objectId") || this.objectId != null && this.objectId.HasValue)
                {
                    s.Serialize("objectId", ref this.objectId.Value);
                    this.objectId.HasValue = true;
                }
                if (s.HasKey("set") || this.set != null && this.set.HasValue)
                {
                    s.SerializeDictionary<MapOfInt, int>("set", ref this.set.Value);
                    this.set.HasValue = true;
                }
            }
        }


        private static async Promise TryBumpStat(ISignedRequester requester, long id, string key, long value)
        {
            try
            {
                requester.SetPlayerId(id);
                await requester.Request<Api.Autogenerated.Models.EmptyResponse>(Method.POST, $"/object/stats/client.private.player.{id}", new StatIntUpdateRequest()
                {
                    add = new OptionalMapOfLong{HasValue = true, Value = new MapOfLong(){{key,value}}},
                    objectId = id.ToString(),
                });
                BeamableLogger.Log($"Set stat {key} to {value}");
            } catch (Exception e)
            {
                BeamableLogger.LogError(e);
                
                requester.SetPlayerId(id);
                await requester.Request<Api.Autogenerated.Models.EmptyResponse>(Method.POST, $"/object/stats/client.private.player.{id}", new StatIntUpdateRequest()
                {
                    set = new OptionalMapOfInt()
                    {
                        HasValue = true,
                        Value = new MapOfInt(){{key, 1}}
                    },
                    // objectId = id.ToString(),
                });
            }
        }
        private static async Promise<long> TryGetIntStat(IBeamableRequester requester, long id, string key, int defaultValue)
        {
            try
            {
                var stats = await requester.Request(Method.GET,
                    $"/object/stats/client.private.player.{id}",
                    null, true, s=> JsonSerializable.FromJson<StatsFullResponse>(s));
                if (stats.statsNumeric.TryGetValue(key, out var l))
                {
                    return l;
                }
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
            }
            return defaultValue;
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<long> TheStat(string itemType)
        {
            var beamId = Context.UserId;
            var key = $"Forged-{itemType}";
            var forgedTimes = await TryGetIntStat(Requester, beamId, key, 0);
            BeamableLogger.Log($"Forged times: {forgedTimes}");
            return forgedTimes;
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task TheStatss()
        {
            var beamId = Context.UserId;
            var stats = await Requester.Request(Method.GET,
                $"/object/stats/game.private.player.{beamId}",
                null, true, s=> JsonSerializable.FromJson<StatsFullResponse>(s));
            BeamableLogger.Log("Stats numeric: {numeric}, rest {rest}", stats.statsNumeric.Count, stats.stats.Count);
        }
        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task BumpStat(string itemType)
        {
            var beamId = Context.UserId;
            var key = $"Forged-{itemType}";
            await TryBumpStat(SignedRequester, beamId, key, 1);
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task TestingPrompt(string itemId)
        {
            var contentApi = Provider.GetService<AiContentService>();
            var chat = Provider.GetService<ChatAiService>();
            var beamId = Context.UserId;
            if (!contentApi.TryGetContent(itemId, out var content))
            {
                BeamableLogger.LogWarning("{ItemId} is not an AiItemContent", itemId);
                return;
            }

            var result = await chat.MakeNewInventoryItem(content, beamId.ToString(), 10);
            var json = JsonConvert.SerializeObject(result);
            BeamableLogger.Log(json);

        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<bool> SellSword(string itemId)
        {
            var itemIdLong = long.Parse(itemId);
            // var user = await Services.Auth.GetUser();

            // var id = user.external.FirstOrDefault().userId;
            // var db = await Storage.ForgeStorageDatabase();
            // var items = await AiInventoryItemCollection.GetAll(db, id);
            // BeamableLogger.Log($"User {user.id} with ID: {id} has {items.Count} items");
            var inv = await Services.Inventory.GetCurrent("items");
            ItemView item = null;
            foreach (var items in inv.items)
            {
                var stop = false;
                foreach (var itemView in items.Value)
                {
                    if (itemView.id == itemIdLong)
                    {
                        item = itemView;
                        stop = true;
                        break;
                    }
                }

                if (stop)
                {
                    break;
                }
            }
            
            if (item is null)
            {
                BeamableLogger.LogWarning("Item {ID} not found", itemId);
                BeamableLogger.LogWarning("Valid ids: {ids}", string.Join(",", inv.items.Values.Select(s=> string.Join(",", s.Select(ss=> ss.id)))));
                return false;
            }

            var reward = 0;
            if (int.TryParse(item.properties.GetValueOrDefault("price", "10"), out int price))
            {
                reward = price;
            }
            var check = new InventoryUpdateBuilder();
            check.DeleteItem(item.contentId, item.id);
            check.CurrencyChange("currency.coins", reward);
            await Services.Inventory.Update(check);
            return true;
        }

        [ClientCallable]
        public async Task TriggerInventoryRefresh()
        {
            await Provider.GetService<IBeamableRequester>()
                .Request<Unit>(Method.PUT, $"/object/inventory/{Context.UserId}/proxy/reload");
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public Task<bool> StartForgingSword()
        {
            return ForgeItem(SwordContentId);
        }

        
        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public Task<bool> StartForgingShield()
        {
            return ForgeItem(ShieldContentId);
        }
        

        public Promise<FederatedAuthenticationResponse> Authenticate(string token, string challenge,
            string solution)
        {
            return Promise<FederatedAuthenticationResponse>.Successful(new FederatedAuthenticationResponse { user_id = token });
        }
        
        public async Task<bool> ForgeItem(string itemId)
        {
            var contentApi = Provider.GetService<AiContentService>();
            if (!contentApi.TryGetContent(itemId, out var content))
            {
                return false;
            }
            
            try
            {
                var currencyCost = content.GetForgePrice();
                var forgedTimesPromise = TryGetIntStat(SignedRequester, Context.Id, content.StatKey(), 0);
                var inventoryViewPromise = Services.Inventory.GetCurrent("currency.coins");
                var inventoryView = await inventoryViewPromise;
                var forgedTimes = await forgedTimesPromise;
                
                
                long currency = inventoryView.currencies.GetValueOrDefault("currency.coins", 0);
                if (currency > currencyCost)
                {
                    var check = new InventoryUpdateBuilder();
                    check.AddItem(itemId, new Dictionary<string, string>{{"forgedTimes", forgedTimes.ToString()}});
                    check.CurrencyChange("currency.coins", -currencyCost);
                    BeamableLogger.Log("Start forging {Item} that costs {Cost}", itemId, currencyCost);
                    await Services.Inventory.Update(check);
                    return true;
                }
            }
            catch (Exception e)
            {
                BeamableLogger.LogException(e);
            }
            return false;
        }
        

        [ServerCallable]
        public async Task GenerateImage(string itemId)
        {
            var stopWatch = Stopwatch.StartNew();
            var chat = Provider.GetService<ChatAiService>();
            var db = await Storage.ForgeStorageDatabase();
            BeamableLogger.Log("Gen Image- got storage, time {Time}", stopWatch.ElapsedMilliseconds);
            var items = await AiInventoryItemCollection.GetItem(db, itemId);
            BeamableLogger.Log("Gen Image- got item, time {Time}", stopWatch.ElapsedMilliseconds);
            var item = items[0];
            if (item.Properties.ContainsKey("imageUrl"))
            {   
                BeamableLogger.Log("Skip gen image");
                await Provider.GetService<IBeamableRequester>()
                    .Request<Unit>(Method.PUT, $"/object/inventory/{item.GamerTag}/proxy/reload");
                BeamableLogger.Log("Gen Image- reloaded proxy, time {Time}", stopWatch.ElapsedMilliseconds);
                return;
            }

            if (!item.Properties.TryGetValue("image", out var imagePrompt))
            {
                if (!Provider.GetService<AiContentService>().TryGetContent(item.ContentId, out var aiItemContent))
                {
                    return;
                }
                var signedRequester = SignedRequester;
                signedRequester.SetPlayerId(item.GamerTag);
                var stat = await TryGetIntStat(signedRequester, long.Parse(item.GamerTag), aiItemContent.StatKey(), 0);
                await Services.Scheduler.Schedule().Microservice<ForgeService>().Run(t => t.RebuildItem, itemId, stat)
                    .After(TimeSpan.FromSeconds(10)).Save($"rebuild-item-{itemId}");
                return;
            }
            
            var image = await chat.GenerateImage(imagePrompt);
            BeamableLogger.Log("Gen Image- got image, time {Time}", stopWatch.ElapsedMilliseconds);
            item.Properties["image"] = image;
            var collection = await AiInventoryItemCollection.Get(db);
            await collection.FindOneAndReplaceAsync(x => x.ItemId == itemId, item);
            BeamableLogger.Log("Gen Image- updated item, time {Time}", stopWatch.ElapsedMilliseconds);
            await Provider.GetService<IBeamableRequester>()
                .Request<Unit>(Method.PUT, $"/object/inventory/{item.GamerTag}/proxy/reload");
            BeamableLogger.Log("Gen Image- reloaded proxy, time {Time}", stopWatch.ElapsedMilliseconds);
        }

        [ServerCallable]
        public async Task RebuildItem(string itemId, long forgedTimes)
        {
            var stopWatch = Stopwatch.StartNew();
            var chat = Provider.GetService<ChatAiService>();
            var db = await Storage.ForgeStorageDatabase();
            BeamableLogger.Log("Rebuild Item- got storage, time {Time}", stopWatch.ElapsedMilliseconds);
            var items = await AiInventoryItemCollection.GetItem(db, itemId);
            BeamableLogger.Log("Rebuild Item- got item, time {Time}", stopWatch.ElapsedMilliseconds);
            var item = items[0];
            if (item.Properties.ContainsKey("image"))
            {   
                return;
            }
            if (!Provider.GetService<AiContentService>().TryGetContent(item.ContentId, out var aiItemContent))
            {
                BeamableLogger.LogWarning("{ContentId} is not an AiItemContent", item.ContentId);
                return;
            }
            BeamableLogger.Log("Rebuild Item Sending prompt to AI API, time {Time}", stopWatch.ElapsedMilliseconds);
            var cc = await chat.GetChat();
            var aiResponse = await cc.Prompt(aiItemContent.Prompt(forgedTimes));
            BeamableLogger.Log("Rebuild Item Received responses {C}, time {Time}", aiResponse, stopWatch.ElapsedMilliseconds);

            if (ChatAiService.TryParseAiResponse(aiResponse, out var aiProps))
            {
                aiProps["price"] = ChatAiService.CalculatePrice(aiResponse).ToString();
            }

            foreach (var aiProp in aiProps)
            {
                item.Properties[aiProp.Key] = aiProp.Value;
            }
            var collection = await AiInventoryItemCollection.Get(db);
            await collection.FindOneAndReplaceAsync(x => x.ItemId == itemId, item);
            await Services.Scheduler.Schedule().Microservice<ForgeService>().Run(t => t.GenerateImage, itemId)
                .After(TimeSpan.FromSeconds(10)).Save($"genImage-{itemId}");
        }
    }
}
