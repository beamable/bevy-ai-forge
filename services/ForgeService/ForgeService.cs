using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Inventory;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;
using ForgeService.Storage;
using Newtonsoft.Json;
using OpenAI.Chat;

namespace Beamable.ForgeService
{
    [FederationId("OpenAI")]
	public class AiCloudIdentity : IFederationId;

	[Microservice("ForgeService")]
	public partial class ForgeService : Microservice, IFederatedInventory<AiCloudIdentity>, IFederatedLogin<AiCloudIdentity>
	{
        const string SwordContentId = "items.AiItemContent.AiSword";
        private static string openApiKey;
        static ChatClient GetClient() => new ChatClient(model: "gpt-4o", apiKey: openApiKey);

        [InitializeServices]
        public static async Task Initialize(IServiceInitializer initializer)
        {
            var realmConfigService = initializer.GetService<IMicroserviceRealmConfigService>();
            var config = await realmConfigService.GetRealmConfigSettings();
            var appId = config.GetSetting("ForgeService", "openApiKey", string.Empty);
            if (string.IsNullOrWhiteSpace(appId))
            {
                throw new MicroserviceException((int)HttpStatusCode.BadRequest, "ConfigurationError",
                    "steam.appid is not defined in realm config. Please apply the configuration and restart the service to make it operational.");
            }

            openApiKey = appId;
        }

		public async Promise<FederatedInventoryProxyState> GetInventoryState(string id)
		{
			BeamableLogger.LogWarning($"GetInventoryState {id}");
			var db = await Storage.ForgeStorageDatabase();
			var items = await AiInventoryItemCollection.GetAll(db, id);
			return items.ToFederatedInventoryProxyState();
		}
        public async Promise<FederatedInventoryProxyState> StartInventoryTransaction(string id, string transaction, Dictionary<string, long> currencies, List<FederatedItemCreateRequest> newItems, List<FederatedItemDeleteRequest> deleteItems,
            List<FederatedItemUpdateRequest> updateItems)
        {
            BeamableLogger.LogWarning($"StartInventoryTransaction {id}: {newItems.Count}");
            try
            {
                var client = GetClient();
                var db = await Storage.ForgeStorageDatabase();
                var items = new ConcurrentBag<AiInventoryItem>(await AiInventoryItemCollection.GetAll(db, id));

                var services = Services;
                var requester = Requester;

                foreach (var newItem in newItems)
                {
                    _ = Task.Run(async () =>
                    {
                        BeamableLogger.Log("Starting task for {item}", newItem.contentId);
                        try
                        {
                            var contentObject = await services.Content.GetContent(newItem.contentId);
                            var aiItemContent = contentObject as AiItemContent;
                            if (aiItemContent is null)
                            {
                                BeamableLogger.LogWarning("{ContentId} is not an AiItemContent", newItem.contentId);
                                return;
                            }
                            var key = $"Forged-{aiItemContent.itemType}";
                            var longId = long.Parse(id);
                            var forgedTimes = await TryGetIntStat(longId, key, 0);
                            var prompt = @$"I want to create 1 game item.
						    Item should be of type: '{aiItemContent.itemType}'.
						    Game theme is: '{aiItemContent.itemTheme}'.\n";
                            if (forgedTimes < 5)
                            {
                                prompt += "Item is crafted by someone without any experience with poor value.\n";
                            }
                            if (forgedTimes > 30)
                            {
                                prompt += "Item is crafted by someone with vast experience.\n";
                            }
                            prompt += @$"
						    Here is the list of item properties with descriptions, as JSON: {JsonConvert.SerializeObject(aiItemContent.dynamicProperties)}
						    Format the output as JSON object containing only properties.";

                            BeamableLogger.Log("Sending {Prompt} to OpenAI API...", prompt);
                            var aiResponse = await client.CompleteChatAsync([new UserChatMessage(prompt)], new ChatCompletionOptions
                            {
                                Temperature = (float?)0.9,
                                MaxOutputTokenCount = 1500,
                            }
                            );
                            BeamableLogger.Log("Received responses {C}",
                                aiResponse.Value.Content.FirstOrDefault()?.Text);

                            if (aiResponse.Value.Content.Count > 0 &&
                                TryParseAiResponse(aiResponse.Value.Content.First().Text, out var aiProps))
                            {
                                aiProps.Add("price", CalculatePrice(aiResponse.Value.Content.First().Text).ToString());
                                var newAiItem = new AiInventoryItem
                                {
                                    ContentId = newItem.contentId,
                                    GamerTag = id,
                                    Properties = aiProps
                                };
                                // if (newItem.contentId == SwordContentId)
                                // {
                                //     try
                                //     {
                                //         var imagePrompt = newAiItem.Properties.GetValueOrDefault("image") ??
                                //                           aiItemContent.itemType;
                                //         BeamableLogger.Log("Generating image for {imagePrompt}", imagePrompt);
                                //         var imageUrl = await GetScenarioImage(imagePrompt);
                                //         newAiItem.Properties["image"] = imageUrl;
                                //         BeamableLogger.Log("Generated image {i}", imageUrl);
                                //     }
                                //     catch (Exception e)
                                //     {
                                //         BeamableLogger.Log($"Failed to generate image for {newItem.contentId}, {e.ToString()}");
                                //     }
                                // }

                                await AiInventoryItemCollection.Save(db, newAiItem);
                                BeamableLogger.Log("Saved item {ID}", newAiItem.ItemId);
                                items.Add(newAiItem);
                                forgedTimes++;
                                await services.Stats.SetProtectedPlayerStat(longId, key, forgedTimes.ToString());
                                BeamableLogger.Log($"Set stat {key} to {forgedTimes}");

                                BeamableLogger.Log("Reporting back state for {ID}", newAiItem.ItemId);
                                await requester.Request<CommonResponse>(Method.PUT,
                                    $"/object/inventory/{id}/proxy/state",
                                    items.ToFederatedInventoryProxyState());
                                BeamableLogger.Log("Reported state for {ID}", newAiItem.ItemId);
                            }
                        }
                        catch (Exception ex)
                        {
                            BeamableLogger.LogError(ex);
                        }
                    });
                }

                return items.ToFederatedInventoryProxyState();
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
                throw;
            }
        }

        private bool TryParseAiResponse(string response, out Dictionary<string, string> aiProps)
        {
            aiProps = null;
            if (string.IsNullOrWhiteSpace(response)) 
                return false;
            try
            {
                var startIndex = 0;
                for (; startIndex < response.Length; startIndex++)
                {
                    if (response[startIndex].Equals('{'))
                    {
                        break;
                    }
                }
                var endIndex = response.Length - 1;
                for (; endIndex >= startIndex; endIndex--)
                {
                    if (response[endIndex].Equals('}'))
                    {
                        endIndex += 1;
                        break;
                    }
                }

                if (startIndex >= endIndex)
                    return false;
                var trimmed = response[startIndex..endIndex].Replace("\\\"", "\"");
                BeamableLogger.Log($"Parsing: {trimmed}");
                aiProps = JsonConvert.DeserializeObject<Dictionary<string, string>>(trimmed);
                return true;
            }
            catch (Exception ex)
            {
                BeamableLogger.LogError(ex);
                return false;
            }
        }


        private async Promise<int> TryGetIntStat(long id, string key, int defaultValue)
        {
            try
            {
                var value = await Services.Stats.GetProtectedPlayerStat(id, key);
                if (string.IsNullOrWhiteSpace(value)) return defaultValue;
                if(int.TryParse(value, out var number))
                    return number;
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
                return defaultValue;
            }
            return defaultValue;
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<bool> SellSword(string itemId)
        {
            var id = Context.UserId.ToString();
            var db = await Storage.ForgeStorageDatabase();
            var items = await AiInventoryItemCollection.GetAll(db, id);

            var item = items.FirstOrDefault(item => item.ItemId == itemId);
            if (item is not null)
            {
                var reward = 0;
                if (int.TryParse(item.Properties.GetValueOrDefault("price", "10"), out int price))
                {
                    reward = price;
                }

                BeamableLogger.Log("Deleting item");
                await AiInventoryItemCollection.Delete(db, item);
                items.Remove(item);

                BeamableLogger.Log("Adding currency");
                await Services.Inventory.AddCurrency("currency.coins", reward);

                BeamableLogger.Log("Reporting back state");
                await Requester.Request<CommonResponse>(Method.PUT, $"/object/inventory/{id}/proxy/state",
                    items.ToFederatedInventoryProxyState());

                return true;
            }

            BeamableLogger.LogWarning("Item {ID} not found", itemId);
            return false;
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<bool> StartForgingSword()
        {
            try
            {
                var currencyCost = 50;
                var currency = await Services.Inventory.GetCurrency("currency.coins");
                if (currency > currencyCost)
                {
                    await Services.Inventory.SetCurrency("currency.coins", currency - currencyCost);
                    await Services.Inventory.AddItem(SwordContentId);
                }
                else { return false; }
            }
            catch (Exception e)
            {
                BeamableLogger.LogException(e);
                return false;
            }

            return true;
        }

        [Callable]
        [SwaggerCategory("Common")]
        public string SayHi(string name)
        {
            BeamableLogger.Log($"{Context.UserId}: {string.Join(",", Context.Scopes)}");
            var typeInfo = Context.UserId <= 0 ? "Anonymous" : Context.IsAdmin ? "Admin" : "Regular User";
            return $"Hi, {name}! Call performed by {typeInfo}. UserID: {Context.UserId}";
        }
        
        private int CalculatePrice(string input)
        {
            const int basePrice = 51;
            const int randomize = 33;
            return Math.Abs(input.GetHashCode()) % randomize + basePrice;
        }

        public async Promise<FederatedAuthenticationResponse> Authenticate(string token, string challenge,
            string solution)
        {
            BeamableLogger.Log("Authenticate");
            await Task.Delay(1);
            return new FederatedAuthenticationResponse { user_id = Context.UserId.ToString() };
        }
    }
}
