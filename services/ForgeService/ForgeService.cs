using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Inventory;
using Beamable.Common.Api.Stats;
using Beamable.Common.Content;
using Beamable.Serialization;
using Beamable.Serialization.SmallerJSON;
using Beamable.Server;
using Beamable.Server.Api.Content;
using Beamable.Server.Api.RealmConfig;
using ForgeService.Storage;
using Newtonsoft.Json;
using OpenAI.Chat;

namespace Beamable.ForgeService
{
    [FederationId("OpenAI")]
	public class AiCloudIdentity : IFederationId;

	[Microservice("ForgeService")]
	public partial class ForgeService : Microservice, IFederatedInventory<AiCloudIdentity>, IFederatedLogin<AiCloudIdentity>
	{
        const string SwordContentId = "items.AiItemContent.AiSword";

        // private static string openApiKey;
        // static ChatClient GetClient() => new ChatClient(model: "gpt-4o", apiKey: openApiKey);

        [ConfigureServices]
        public static void ConfigureServices(IServiceBuilder builder)
        {
            builder.AddSingleton(provider => new ChatAiService(provider.GetService<IMicroserviceRealmConfigService>(), provider.GetService<IContentApi>()));
            builder.AddSingleton(provider => new AiContentService(provider.GetService<IMicroserviceContentApi>()));
        }
        
        [InitializeServices]
        public static async Task Initialize(IServiceInitializer initializer)
        {
            try
            {
                var t = initializer.GetService<AiContentService>().Init();
                _ = await initializer.GetService<ChatAiService>().GetChat();
                await t;
            }
            catch (Exception e)
            {
                throw new MicroserviceException((int)HttpStatusCode.BadRequest, "ConfigurationError",
                    e.Message);

            }
        }

		public async Promise<FederatedInventoryProxyState> GetInventoryState(string id)
		{
            BeamableLogger.LogWarning($"GetInventoryState {id}");
            BeamableLogger.LogWarning($"GetInventoryState services: {Services != null}");
            BeamableLogger.LogWarning($"GetInventoryState ctx: {Context != null}");
            BeamableLogger.LogWarning($"GetInventoryState signed requester: {SignedRequester != null}");
            BeamableLogger.LogWarning($"GetInventoryState requester: {Requester != null}");
			var db = await Storage.ForgeStorageDatabase();
			var items = await AiInventoryItemCollection.GetAll(db, id);
			return items.ToFederatedInventoryProxyState();
		}
        public async Promise<FederatedInventoryProxyState> StartInventoryTransaction(string id, string transaction, Dictionary<string, long> currencies, List<FederatedItemCreateRequest> newItems, List<FederatedItemDeleteRequest> deleteItems,
            List<FederatedItemUpdateRequest> updateItems)
        {
            var beamId = Context.UserId;
            BeamableLogger.LogWarning($"StartInventoryTransaction {id} - {beamId}: {newItems.Count}");
            try
            {
                var db = await Storage.ForgeStorageDatabase();
                var contentApi = Provider.GetService<AiContentService>();
                var chat = Provider.GetService<ChatAiService>();
                var signedRequester = SignedRequester;
                BeamableLogger.Log($"Is signedRequester empty: {signedRequester == null}");
                signedRequester.SetPlayerId(id);

                foreach (var newItem in newItems)
                {
                    _ = Task.Run(async () =>
                    {
                        BeamableLogger.Log("Starting task for {item}", newItem.contentId);
                        if (!contentApi.TryGetContent(newItem.contentId, out var aiItemContent))
                        {
                            BeamableLogger.LogWarning("{ContentId} is not an AiItemContent", newItem.contentId);
                            return;
                        }

                        var key = aiItemContent.StatKey();
                        try
                        {
                            var forgedTimes = await TryGetIntStat(signedRequester, beamId, key, 0);
                            BeamableLogger.Log($"Forged times: {forgedTimes}");

                            var newAiItem = await chat.MakeNewInventoryItem(aiItemContent, id, forgedTimes);

                            await AiInventoryItemCollection.Save(db, newAiItem);
                            BeamableLogger.Log("Saved item {ID}", newAiItem.ItemId);
                            // items.Add(newAiItem);
                            // var forgedTimesUpdated = await TryGetIntStat(signedRequester, beamId, key, 0);
                            // forgedTimesUpdated++;
                            TryBumpStat(signedRequester, beamId, key, 1);

                            // BeamableLogger.Log("Reporting back state for {ID}", newAiItem.ItemId);
                            // await requester.Request<CommonResponse>(Method.PUT,
                            //     $"/object/inventory/{beamId}/proxy/state",
                            //     items.ToFederatedInventoryProxyState());
                            // BeamableLogger.Log("Reported state for {ID}", newAiItem.ItemId);
                        }
                        catch (Exception ex)
                        {
                            BeamableLogger.LogError(ex);
                        }
                    });
                }

                var items = new ConcurrentBag<AiInventoryItem>(await AiInventoryItemCollection.GetAll(db, id));
                return items.ToFederatedInventoryProxyState();
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
                throw;
            }
        }


        [Serializable]
        class StatsRequest
        {
            public string stats;
        }
        [Serializable]
        public class StatsFullResponse : JsonSerializable.ISerializable
        {
            public long id;
            public MapOfString stats = new MapOfString();
            public MapOfLong statsNumeric = new MapOfLong();

            public virtual void Serialize(JsonSerializable.IStreamSerializer s)
            {
                s.Serialize("id", ref this.id);
                s.SerializeDictionary<MapOfString, string>("stats", ref this.stats);
                if (s.isLoading)
                {
                    var ss = s.GetValue("stats") as ArrayDict;
                    stats.Clear();
                    statsNumeric.Clear();
                    foreach (var (key, value) in ss)
                    {
                        if (value is long l)
                        {
                            statsNumeric.Add(key, l);
                        }
                        else
                        {
                            stats.Add(key, value.ToString());
                        }
                    }
                }

                if (s.isSaving)
                {
                    var array = new ArrayDict();
                    foreach (var (key, value) in stats)
                    {
                        array.Add(key, value);
                    }

                    foreach (var (k,v) in statsNumeric)
                    {
                        array.Add(k, v);
                    }
                    s.SetValue("stats", array);
                }
            }
        }

        [Serializable]
        public class StatIntUpdateRequest : JsonSerializable.ISerializable
        {
            public OptionalMapOfLong add = new OptionalMapOfLong();
            public OptionalBool emitAnalytics = new OptionalBool();
            public OptionalString objectId = new OptionalString();
            public OptionalMapOfInt set = new OptionalMapOfInt();

            public virtual void Serialize(JsonSerializable.IStreamSerializer s)
            {
                if (s.HasKey("add") || this.add != null && this.add.HasValue)
                {
                    s.SerializeDictionary<MapOfLong, long>("add", ref this.add.Value);
                    this.add.HasValue = true;
                }
                if (s.HasKey("emitAnalytics") || this.emitAnalytics != null && this.emitAnalytics.HasValue)
                {
                    s.Serialize("emitAnalytics", ref this.emitAnalytics.Value);
                    this.emitAnalytics.HasValue = true;
                }
                if (s.HasKey("objectId") || this.objectId != null && this.objectId.HasValue)
                {
                    s.Serialize("objectId", ref this.objectId.Value);
                    this.objectId.HasValue = true;
                }
                if (s.HasKey("set") || this.set != null && this.set.HasValue)
                {
                    s.SerializeDictionary<MapOfInt, int>("set", ref this.set.Value);
                    this.set.HasValue = true;
                }
            }
        }


        private static async Promise TryBumpStat(ISignedRequester requester, long id, string key, long value)
        {
            try
            {
                requester.SetPlayerId(id);
                await requester.Request<Api.Autogenerated.Models.EmptyResponse>(Method.POST, $"/object/stats/client.private.player.{id}", new StatIntUpdateRequest()
                {
                    add = new OptionalMapOfLong{HasValue = true, Value = new MapOfLong(){{key,value}}},
                    objectId = id.ToString(),
                });
                BeamableLogger.Log($"Set stat {key} to {value}");
            } catch (Exception e)
            {
                BeamableLogger.LogError(e);
            }
        }
        private static async Promise<long> TryGetIntStat(IBeamableRequester requester, long id, string key, int defaultValue)
        {
            try
            {
                var stats = await requester.Request(Method.GET,
                    $"/object/stats/client.private.player.{id}",
                    null, true, s=> JsonSerializable.FromJson<StatsFullResponse>(s));
                if (stats.statsNumeric.TryGetValue(key, out var l))
                {
                    return l;
                }
                // var stats = await requester.Request<StatsResponse>(Method.GET, $"/object/stats/client.private.player.{id}",
                //     new StatsRequest() { stats = key }, true, s =>
                //     {
                //         var dictionary = Json.Deserialize(s) as ArrayDict;
                //         long id = 0;
                //         if (dictionary["id"] is long test)
                //         {
                //             id = test;
                //         }
                //
                //         var stats = new StatsResponse()
                //         {
                //             id = id,
                //             stats = new MapOfString()
                //         };
                //         if (dictionary["stats"] is ArrayDict stat)
                //         {
                //             foreach (var (key, value) in stat)
                //             {
                //                 if (value is string ss)
                //                 {
                //                     stats.stats.Add(key, ss);
                //                 }
                //             }
                //         }
                //         return stats;
                //     });
                if (!stats.stats.TryGetValue(key, out string value))
                {
                    return defaultValue;
                }
                if (string.IsNullOrWhiteSpace(value)) 
                    return defaultValue;
                if(long.TryParse(value, out var number))
                    return number;
                return defaultValue;
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
            }
            return defaultValue;
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<long> TheStat(string itemType)
        {
            var beamId = Context.UserId;
            var key = $"Forged-{itemType}";
            var forgedTimes = await TryGetIntStat(Requester, beamId, key, 0);
            BeamableLogger.Log($"Forged times: {forgedTimes}");
            return forgedTimes;
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task TheStatss()
        {
            var beamId = Context.UserId;
            var stats = await Requester.Request(Method.GET,
                $"/object/stats/game.private.player.{beamId}",
                null, true, s=> JsonSerializable.FromJson<StatsFullResponse>(s));
            BeamableLogger.Log("Stats numeric: {numeric}, rest {rest}", stats.statsNumeric.Count, stats.stats.Count);
        }
        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task BumpStat(string itemType)
        {
            var beamId = Context.UserId;
            var key = $"Forged-{itemType}";
            try
            {
                await Requester.Request<Api.Autogenerated.Models.EmptyResponse>(Method.POST, $"/object/stats/client.private.player.{beamId}", JsonSerializable.ToJson(new StatIntUpdateRequest()
                {
                    add = new OptionalMapOfLong{HasValue = true, Value = new MapOfLong(){{key,1}}}
                }));
                // await TryUpdateStat(SignedRequester, beamId, key, 1);
            }catch(Exception e)
            {
                BeamableLogger.LogError(e);
            }
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task TestingPrompt(string itemId)
        {
            var contentApi = Provider.GetService<AiContentService>();
            var chat = Provider.GetService<ChatAiService>();
            var beamId = Context.UserId;
            if (!contentApi.TryGetContent(itemId, out var content))
            {
                BeamableLogger.LogWarning("{ItemId} is not an AiItemContent", itemId);
                return;
            }

            var result = await chat.MakeNewInventoryItem(content, beamId.ToString(), 10);
            var json = JsonConvert.SerializeObject(result);
            BeamableLogger.Log(json);

        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<bool> SellSword(string itemId)
        {
            var user = await Services.Auth.GetUser();

            var id = user.external.FirstOrDefault().userId;
            var db = await Storage.ForgeStorageDatabase();
            var items = await AiInventoryItemCollection.GetAll(db, id);
            BeamableLogger.Log($"User {user.id} with ID: {id} has {items.Count} items");
            var item = items.FirstOrDefault(item => item.ItemId == itemId);
            if (item is not null)
            {
                var reward = 0;
                if (int.TryParse(item.Properties.GetValueOrDefault("price", "10"), out int price))
                {
                    reward = price;
                }

                BeamableLogger.Log("Deleting item");
                await AiInventoryItemCollection.Delete(db, item);
                items.Remove(item);

                BeamableLogger.Log("Adding currency");
                await Services.Inventory.AddCurrency("currency.coins", reward);

                BeamableLogger.Log("Reporting back state");
                await Requester.Request<CommonResponse>(Method.PUT, $"/object/inventory/{Context.UserId}/proxy/state",
                    items.ToFederatedInventoryProxyState());
                return true;
            }

            BeamableLogger.LogWarning("Item {ID} not found", itemId);
            return false;
        }

        [ClientCallable]
        public async Task TriggerInventoryRefresh()
        {
            await Provider.GetService<IBeamableRequester>()
                .Request<Unit>(Method.PUT, $"/object/inventory/{Context.UserId}/proxy/reload");
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<bool> StartForgingSword()
        {
            try
            {
                // var status = await Services.Auth.AttachIdentity(Context.UserId.ToString(),"ForgeService",  "OpenAI");
                var currencyCost = 50;
                var inventoryView = await Services.Inventory.GetCurrent("currency.coins");
                
                long currency = inventoryView.currencies.GetValueOrDefault("currency.coins", 0);
                if (currency > currencyCost)
                {
                    var check = new InventoryUpdateBuilder();
                    check.AddItem(SwordContentId);
                    check.CurrencyChange("currency.coins", -currencyCost);
                    await Services.Inventory.Update(check);
                    return true;
                }
            }
            catch (Exception e)
            {
                BeamableLogger.LogException(e);
            }
            return false;
        }
        

        public Promise<FederatedAuthenticationResponse> Authenticate(string token, string challenge,
            string solution)
        {
            return Promise<FederatedAuthenticationResponse>.Successful(new FederatedAuthenticationResponse { user_id = token });
        }
    }
}
