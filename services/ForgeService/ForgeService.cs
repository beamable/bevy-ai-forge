using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Inventory;
using Beamable.Common.Api.Stats;
using Beamable.Common.Content;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;
using ForgeService.Storage;
using Newtonsoft.Json;
using OpenAI.Chat;
using CurrencyProperty = Beamable.Common.Api.Inventory.CurrencyProperty;
using ItemCreateRequest = Beamable.Common.Api.Inventory.ItemCreateRequest;
using ItemDeleteRequest = Beamable.Common.Api.Inventory.ItemDeleteRequest;
using ItemUpdateRequest = Beamable.Common.Api.Inventory.ItemUpdateRequest;

namespace Beamable.ForgeService
{
    [FederationId("OpenAI")]
	public class AiCloudIdentity : IFederationId;

	[Microservice("ForgeService")]
	public partial class ForgeService : Microservice, IFederatedInventory<AiCloudIdentity>, IFederatedLogin<AiCloudIdentity>
	{
        const string SwordContentId = "items.AiItemContent.AiSword";

        // private static string openApiKey;
        // static ChatClient GetClient() => new ChatClient(model: "gpt-4o", apiKey: openApiKey);

        [ConfigureServices]
        public static void ConfigureServices(IServiceBuilder builder)
        {
            builder.AddSingleton<ChatAiService>();
        }
        
        [InitializeServices]
        public static async Task Initialize(IServiceInitializer initializer)
        {
            try
            {
                _ = await initializer.GetService<ChatAiService>().GetChat();
            }
            catch (Exception e)
            {
                throw new MicroserviceException((int)HttpStatusCode.BadRequest, "ConfigurationError",
                    e.Message);

            }
        }

		public async Promise<FederatedInventoryProxyState> GetInventoryState(string id)
		{
			BeamableLogger.LogWarning($"GetInventoryState {id}");
			var db = await Storage.ForgeStorageDatabase();
			var items = await AiInventoryItemCollection.GetAll(db, id);
			return items.ToFederatedInventoryProxyState();
		}
        public async Promise<FederatedInventoryProxyState> StartInventoryTransaction(string id, string transaction, Dictionary<string, long> currencies, List<FederatedItemCreateRequest> newItems, List<FederatedItemDeleteRequest> deleteItems,
            List<FederatedItemUpdateRequest> updateItems)
        {
            var beamId = Context.UserId;
            BeamableLogger.LogWarning($"StartInventoryTransaction {id} - {beamId}: {newItems.Count}");
            try
            {
                var db = await Storage.ForgeStorageDatabase();
                var items = new ConcurrentBag<AiInventoryItem>(await AiInventoryItemCollection.GetAll(db, id));

                var services = Services;
                var requester = Requester;

                foreach (var newItem in newItems)
                {
                    _ = Task.Run(async () =>
                    {
                        BeamableLogger.Log("Starting task for {item}", newItem.contentId);
                        try
                        {
                            var contentObject = await services.Content.GetContent(newItem.contentId);
                            var aiItemContent = contentObject as AiItemContent;
                            if (aiItemContent is null)
                            {
                                BeamableLogger.LogWarning("{ContentId} is not an AiItemContent", newItem.contentId);
                                return;
                            }
                            var key = $"Forged-{aiItemContent.itemType}";
                            var forgedTimes = await TryGetIntStat(beamId, key, 0);
                            var prompt = @$"I want to create 1 game item.
						    Item should be of type: '{aiItemContent.itemType}'.
						    Game theme is: '{aiItemContent.itemTheme}'.\n";
                            if (forgedTimes < 5)
                            {
                                prompt += "Item is crafted by someone without any experience with poor value.\n";
                            }
                            if (forgedTimes > 30)
                            {
                                prompt += "Item is crafted by someone with vast experience.\n";
                            }
                            prompt += @$"
						    Here is the list of item properties with descriptions, as JSON: {JsonConvert.SerializeObject(aiItemContent.dynamicProperties)}
						    Format the output as JSON object containing only properties.";

                            var newAiItem = await MakeNewInventoryItem(prompt, newItem, id);

                            // if (newItem.contentId == SwordContentId)
                            // {
                            //     try
                            //     {
                            //         var imagePrompt = newAiItem.Properties.GetValueOrDefault("image") ??
                            //                           aiItemContent.itemType;
                            //         BeamableLogger.Log("Generating image for {imagePrompt}", imagePrompt);
                            //         var imageUrl = await GetScenarioImage(imagePrompt);
                            //         newAiItem.Properties["image"] = imageUrl;
                            //         BeamableLogger.Log("Generated image {i}", imageUrl);
                            //     }
                            //     catch (Exception e)
                            //     {
                            //         BeamableLogger.Log($"Failed to generate image for {newItem.contentId}, {e.ToString()}");
                            //     }
                            // }

                            await AiInventoryItemCollection.Save(db, newAiItem);
                            BeamableLogger.Log("Saved item {ID}", newAiItem.ItemId);
                            items.Add(newAiItem);
                            var forgedTimesUpdated = await TryGetIntStat(beamId, key, 0);
                            forgedTimesUpdated++;
                            await services.Stats.SetStat(StatsDomainType.Client, StatsAccessType.Private, beamId, key, forgedTimesUpdated.ToString());
                            BeamableLogger.Log($"Set stat {key} to {forgedTimesUpdated}");

                            BeamableLogger.Log("Reporting back state for {ID}", newAiItem.ItemId);
                            await requester.Request<CommonResponse>(Method.PUT,
                                $"/object/inventory/{beamId}/proxy/state",
                                items.ToFederatedInventoryProxyState());
                            BeamableLogger.Log("Reported state for {ID}", newAiItem.ItemId);
                        }
                        catch (Exception ex)
                        {
                            BeamableLogger.LogError(ex);
                        }
                    });
                }

                return items.ToFederatedInventoryProxyState();
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
                throw;
            }
        }

        private async Task<AiInventoryItem> MakeNewInventoryItem(string prompt, FederatedItemCreateRequest item, string id)
        {
            var client = await Provider.GetService<ChatAiService>().GetChat();
            try
            {
                BeamableLogger.Log("Sending {Prompt} to OpenAI API...", prompt);
                var aiResponse = await client.CompleteChatAsync([new UserChatMessage(prompt)], new ChatCompletionOptions
                    {
                        Temperature = (float?)0.9,
                        MaxOutputTokenCount = 1500,
                    }
                );
                BeamableLogger.Log("Received responses {C}",
                    aiResponse.Value.Content.FirstOrDefault()?.Text);

                if (aiResponse.Value.Content.Count > 0 &&
                    TryParseAiResponse(aiResponse.Value.Content.First().Text, out var aiProps))
                {
                    aiProps.Add("price", CalculatePrice(aiResponse.Value.Content.First().Text).ToString());
                    return new AiInventoryItem
                    {
                        ContentId = item.contentId,
                        GamerTag = id,
                        Properties = aiProps
                    };
                }
            }
            catch
            {
                BeamableLogger.LogError("Calling OpenAI API failed");
            }
            return new AiInventoryItem()
            {
                ContentId = item.contentId,
                GamerTag = id,
                Properties = new Dictionary<string, string>
                {
                    { "price", CalculatePrice(prompt).ToString() }
                }
            };
        }

        private bool TryParseAiResponse(string response, out Dictionary<string, string> aiProps)
        {
            aiProps = null;
            if (string.IsNullOrWhiteSpace(response)) 
                return false;
            try
            {
                var startIndex = 0;
                for (; startIndex < response.Length; startIndex++)
                {
                    if (response[startIndex].Equals('{'))
                    {
                        break;
                    }
                }
                var endIndex = response.Length - 1;
                for (; endIndex >= startIndex; endIndex--)
                {
                    if (response[endIndex].Equals('}'))
                    {
                        endIndex += 1;
                        break;
                    }
                }

                if (startIndex >= endIndex)
                    return false;
                var trimmed = response[startIndex..endIndex].Replace("\\\"", "\"");
                BeamableLogger.Log($"Parsing: {trimmed}");
                aiProps = JsonConvert.DeserializeObject<Dictionary<string, string>>(trimmed);
                return true;
            }
            catch (Exception ex)
            {
                BeamableLogger.LogError(ex);
                return false;
            }
        }


        private async Promise<int> TryGetIntStat(long id, string key, int defaultValue)
        {
            try
            {
                var value = await Services.Stats.GetStat(StatsDomainType.Client, StatsAccessType.Private, id, key);
                if (string.IsNullOrWhiteSpace(value)) return defaultValue;
                if(int.TryParse(value, out var number))
                    return number;
            }
            catch (Exception e)
            {
                BeamableLogger.LogError(e);
            }
            return defaultValue;
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<bool> SellSword(string itemId)
        {
            var user = await Services.Auth.GetUser();

            var id = user.external.FirstOrDefault().userId;
            var db = await Storage.ForgeStorageDatabase();
            var items = await AiInventoryItemCollection.GetAll(db, id);
            BeamableLogger.Log($"User {user.id} with ID: {id} has {items.Count} items");
            var item = items.FirstOrDefault(item => item.ItemId == itemId);
            if (item is not null)
            {
                var reward = 0;
                if (int.TryParse(item.Properties.GetValueOrDefault("price", "10"), out int price))
                {
                    reward = price;
                }

                BeamableLogger.Log("Deleting item");
                await AiInventoryItemCollection.Delete(db, item);
                items.Remove(item);

                BeamableLogger.Log("Adding currency");
                await Services.Inventory.AddCurrency("currency.coins", reward);

                BeamableLogger.Log("Reporting back state");
                await Requester.Request<CommonResponse>(Method.PUT, $"/object/inventory/{Context.UserId}/proxy/state",
                    items.ToFederatedInventoryProxyState());
                return true;
            }

            BeamableLogger.LogWarning("Item {ID} not found", itemId);
            return false;
        }

        [ClientCallable]
        public async Task TriggerInventoryRefresh()
        {
            await Provider.GetService<IBeamableRequester>()
                .Request<Unit>(Method.PUT, $"/object/inventory/{Context.UserId}/proxy/reload");
        }

        [ClientCallable]
        [SwaggerCategory("Inventory")]
        public async Task<bool> StartForgingSword()
        {
            try
            {
                var status = await Services.Auth.AttachIdentity(Context.UserId.ToString(),"ForgeService",  "OpenAI");
                var currencyCost = 50;
                var inventoryView = await Services.Inventory.GetCurrent();
                
                long currency = inventoryView.currencies.GetValueOrDefault("currency.coins", 0);
                if (currency > currencyCost)
                {
                    var check = new InventoryUpdateBuilder();
                    check.AddItem(SwordContentId);
                    check.CurrencyChange("currency.coins", -currencyCost);
                    await Services.Inventory.Update(check);
                    return true;
                }
                else { return false; }
            }
            catch (Exception e)
            {
                BeamableLogger.LogException(e);
            }
            return false;
        }
        
        private int CalculatePrice(string input)
        {
            const int basePrice = 51;
            const int randomize = 33;
            return Math.Abs(input.GetHashCode()) % randomize + basePrice;
        }

        public Promise<FederatedAuthenticationResponse> Authenticate(string token, string challenge,
            string solution)
        {
            return Promise<FederatedAuthenticationResponse>.Successful(new FederatedAuthenticationResponse { user_id = token });
        }
    }
}
